

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The PyConform User’s Manual &mdash; PyConform 0.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PyConform 0.2.2 documentation" href="index.html"/>
        <link rel="next" title="The PyConform Package" href="pyconform.html"/>
        <link rel="prev" title="PyConform" href="readme.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PyConform
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">PyConform</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The PyConform User’s Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-it">What is it?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#how-can-i-install-it">How can I install it?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generating-the-api-documentation">Generating the API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-the-user-documentation">Generating the User Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#before-using-the-pyreshaper">Before Using the PyReshaper</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#how-do-i-use-it">How do I use it?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#some-general-concepts">Some General Concepts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-pyreshaper-from-the-unix-command-line">Using the PyReshaper from the Unix Command-Line</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arguments-to-the-s2smake-script">Arguments to the <code class="docutils literal"><span class="pre">s2smake</span></code> Script</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arguments-to-the-s2srun-script">Arguments to the <code class="docutils literal"><span class="pre">s2srun</span></code> Script</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-pyreshaper-from-within-python">Using the PyReshaper from within Python</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#specifier-object-attributes">Specifier Object Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specifier-object-methods">Specifier Object Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specfiles">Specfiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arguments-to-the-create-reshaper-function">Arguments to the <code class="docutils literal"><span class="pre">create_reshaper()</span></code> Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arguments-to-the-convert-function">Arguments to the <code class="docutils literal"><span class="pre">convert()</span></code> Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-best-performance-with-the-pyreshaper">Obtaining Best Performance with the PyReshaper</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shared-memory">Shared Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-nodes">I/O Nodes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pyconform.html">The PyConform Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">PyConform ChangeLog</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Product License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyConform</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>The PyConform User’s Manual</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/manual.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-pyconform-user-s-manual">
<h1>The PyConform User’s Manual<a class="headerlink" href="#the-pyconform-user-s-manual" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-it">
<h2>What is it?<a class="headerlink" href="#what-is-it" title="Permalink to this headline">¶</a></h2>
<p>PyConform is a tool for converting standardizing large NetCDF datasets,
such as standardization of model output for a model intercomparison
project like CMIP.</p>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<p>PyConform explicitly depends upon the following Python packages:</p>
<ul class="simple">
<li>netCDF4-python</li>
<li>ASAPPyTools</li>
<li>cf_units</li>
<li>pyparsing</li>
<li>dreqPy</li>
</ul>
<p>These packages imply a dependency on the NumPy (v1.4+) and mpi4py (v1.3+)
packages, and the libraries NetCDF, MPI/MPI-2, and UDUNITS2..</p>
<p>If using Python version 2.6, you will need to install the <code class="docutils literal"><span class="pre">ordereddict</span></code>
package, too.</p>
<p>No thorough testing has been done to show whether earlier versions of
these dependencies will work with the PyReshaper. The versions listed
have been shown to work, and it is assumed that later versions will
continue to work.</p>
</div>
</div>
<div class="section" id="how-can-i-install-it">
<h2>How can I install it?<a class="headerlink" href="#how-can-i-install-it" title="Permalink to this headline">¶</a></h2>
<p>The easiest way of obtaining the PyReshaper is from the Python Package
Index (PyPI), using <code class="docutils literal"><span class="pre">pip</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$  pip install [--user] PyReshaper
</pre></div>
</div>
<p>Alternatively, you can download the source from GitHub and install with
<code class="docutils literal"><span class="pre">setuptools</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$  git clone https://github.com/NCAR/PyReshaper
$  cd PyReshaper
$  python setup.py install [--user]
</pre></div>
</div>
<p>This will download and install the most recent stable version of the source
code.  If the most recent version of the non-stable source is desired, you
may switch to the development branch before installing.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$  git checkout devel
</pre></div>
</div>
<p>When installing, the <code class="docutils literal"><span class="pre">--user</span></code> option to either <code class="docutils literal"><span class="pre">pip</span></code> or <code class="docutils literal"><span class="pre">setup.py</span></code>
will install the PyReshaper in the user’s private workspace, as defined
by the system on which the user is installing.  This is useful if you don’t
have permissions to install system-wide software.</p>
<div class="section" id="generating-the-api-documentation">
<h3>Generating the API Documentation<a class="headerlink" href="#generating-the-api-documentation" title="Permalink to this headline">¶</a></h3>
<p>If you are a developer, you may find the Sphinx API documentation helpful
in understanding the design and functionality of the PyReshaper code. To
generate this documentation, you must have Sphinx available and installed.
If you do, the API documentation can be easily generated with the following
command from the <code class="docutils literal"><span class="pre">docs</span></code> directory.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$  make html
</pre></div>
</div>
<p>The API documentation will be placed in the <code class="docutils literal"><span class="pre">docs/build/html/</span></code> directory.</p>
</div>
<div class="section" id="generating-the-user-documentation">
<h3>Generating the User Documentation<a class="headerlink" href="#generating-the-user-documentation" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">README.rst</span></code> file and this User Manual should be consulted for help
on installing and using the software. Both documents are included with
the source. The <code class="docutils literal"><span class="pre">README.rst</span></code> file is included with the top-level
PyReshaper directory, and the User Manual is contained in the
<code class="docutils literal"><span class="pre">docs/source/manual.rst</span></code> file. Both files are reStructuredText formatted
files, meaning they are simple text files that can be read with any text
viewer.</p>
<p>An HTML version of the User Manual will automatically be created by
Sphinx, as described in the previous section. A link will be created
to the manual in the HTML documentation.</p>
</div>
<div class="section" id="before-using-the-pyreshaper">
<h3>Before Using the PyReshaper<a class="headerlink" href="#before-using-the-pyreshaper" title="Permalink to this headline">¶</a></h3>
<p>If you installed the PyReshaper using <code class="docutils literal"><span class="pre">pip</span></code>, then you should be ready to
go.  However, if you using the <code class="docutils literal"><span class="pre">--user</span></code> option, the local install directories
using by <code class="docutils literal"><span class="pre">pip</span></code> may not be in your paths.</p>
<p>First, you must add the installation site-packages directory to your
<code class="docutils literal"><span class="pre">PYTHONPATH</span></code>. If you installed with the <code class="docutils literal"><span class="pre">--user</span></code> option, this means
adding the <code class="docutils literal"><span class="pre">$HOME/.local/lib/python2.X/site-packages</span></code> (on Linux) directory
to your <code class="docutils literal"><span class="pre">PYTHONPATH</span></code>. If you specified a different <code class="docutils literal"><span class="pre">--prefix</span></code> option,
then you must point to that prefix directory. For bash users, this is
done with the following command.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ export PYTHONPATH=$PYTHONPATH:$PREFIX/lib/python2.X/site-packages
</pre></div>
</div>
<p>where the <code class="docutils literal"><span class="pre">$PREFIX</span></code> is the root installation directory used when
installing the PyReshaper package (<code class="docutils literal"><span class="pre">$HOME/.local/</span></code> if using the
<code class="docutils literal"><span class="pre">--user</span></code> option on Linux), and the value of <code class="docutils literal"><span class="pre">X</span></code> will correspond to the
version of Python used to install the PyReshaper package.</p>
<p>If you want to use the command-line interface to the PyReshaper, you
must also add the PyReshaper executables directory to your <code class="docutils literal"><span class="pre">PATH</span></code>.
Like for the <code class="docutils literal"><span class="pre">PYTHONPATH</span></code>, this can be done with the following
command.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ export PATH=$PATH:$PREFIX/bin
</pre></div>
</div>
</div>
</div>
<div class="section" id="how-do-i-use-it">
<h2>How do I use it?<a class="headerlink" href="#how-do-i-use-it" title="Permalink to this headline">¶</a></h2>
<div class="section" id="some-general-concepts">
<h3>Some General Concepts<a class="headerlink" href="#some-general-concepts" title="Permalink to this headline">¶</a></h3>
<p>Before we describe the various ways you can use the PyReshaper, we must
describe more about what, precisely, the PyReshaper is designed to do.</p>
<p>As we’ve already mentioned, the PyReshaper is designed to convert a set
of NetCDF files from time-slice (i.e., synoptic or history-file) format
to time-series (or single-field) format, either in serial or parallel.
Time-slice files contain all of the model variables in one file, but typically
only span 1 or a few time-steps per file.  Time-series files nominally contain
only 1 single time-dependent variable spanning many time-steps, but they
can additionally contain metadata used to describe the single-field variable
contained by the file.</p>
<p>In serial, the PyReshaper will write each time-series variable to its own
file in sequence.  In parallel, time-series variables will be
written simultaneously across the MPI processes allocated for the job.</p>
<p>There are a number of assumptions that the PyReshaper makes regarding the
time-slice (input) data, which we list below.</p>
<ol class="arabic simple">
<li>Each time-slice NetCDF file has multiple time-dependent variables
inside it, but can have many time-independent variables inside it, as
well.</li>
<li>Each time-slice NetCDF file contains data for times that do not
overlap with each other. (That is, each time-slice NetCDF file can
contain data spanning a number of simulation time steps. However, the
span of time contained in one time slice cannot overlap the span of
time in another time-slice.)  If the time-slices overlap, an error
will be given and execution will stop.</li>
<li>Every time-slice NetCDF file contains the same time-dependent
variables, just at differing times.</li>
</ol>
<p>Similarly, there are a number of assumptions made about the time-series
(output) data produced by the PyReshaper conversion process.  The variables
written to the output data can be time-series variables or metadata
variables.  Time-series variables are written to one output file only.
Metadata variables are written to all output files.</p>
<ol class="arabic">
<li><p class="first">By default, every time-dependent variable will be assumed to be a
time-series variable (i.e., written to its own time-series NetCDF file).</p>
</li>
<li><p class="first">Every time-independent variable that appears in the time-slice files
will be assumed to be a metadata variable (i.e., written to every
time-series file).</p>
</li>
<li><p class="first">Users can explicitly specify any number of time-dependent variables
as metadata variables (e.g., such as <code class="docutils literal"><span class="pre">time</span></code> itself).</p>
</li>
<li><p class="first">Every time-series file written by the PyReshaper will span the total
range of time spanned by all time-slice files specified.</p>
</li>
<li><p class="first">Every time-series file will be named with the same prefix and suffix,
according to the rule:</p>
<p>time_series_filename = prefix + variable_name + suffix</p>
</li>
</ol>
<p>where the variable_name is the name of the time-series variable
associated with that time-series file.</p>
<p>It is important to understand the implications of the last assumption on
the list above. Namely, it is important to note what this assumption
means in terms of NetCDF file-naming conventions. It is common for the
file-name to contain information that pertains to the time-sampling
frequency of the data in the file, or the range of time spanned by the
time-series file, or any number of other things. To conform to such
naming conventions, it may be required that the total set of time-slice
files that the user wishes to convert to time-series be given to the
PyReshaper in multiple subsets, running the PyReshaper independently on
each subset of time-slice files. Throughout this manual, we
will refer to such “subsets” as streams. As such, every single PyReshaper
operation is designed to act on a single stream.</p>
</div>
<div class="section" id="using-the-pyreshaper-from-the-unix-command-line">
<h3>Using the PyReshaper from the Unix Command-Line<a class="headerlink" href="#using-the-pyreshaper-from-the-unix-command-line" title="Permalink to this headline">¶</a></h3>
<p>While the most flexible way of using the PyReshaper is from within
Python, as described above, the easiest way to use the PyReshaper is usually
to run the PyReshaper command-line utilities.  In this section, we describe
how to use the command-line utilities <code class="docutils literal"><span class="pre">s2smake</span></code> and <code class="docutils literal"><span class="pre">s2srun</span></code>, which
provide command-line interfaces (CLI) to the PyReshaper. (These scripts
will be installed in the <code class="docutils literal"><span class="pre">$PREFIX/bin</span></code> directory, where <code class="docutils literal"><span class="pre">PREFIX</span></code> is the
installation root directory.  If you installed PyReshaper with the <code class="docutils literal"><span class="pre">--user</span></code>
flag, you may need to add this directpry to your path.)</p>
<p>The <code class="docutils literal"><span class="pre">s2smake</span></code> utility is designed to generate a Specifier object file
(<em>specfile</em>) that contains a specification of the PyReshaper job.
The <code class="docutils literal"><span class="pre">s2srun</span></code> utility is then used to run the PyReshaper with the newly
generated <em>specfile</em>.</p>
<p>Below is an example of how to use the PyReshaper’s <code class="docutils literal"><span class="pre">s2smake</span></code> utility,
with all options and parameters specified on the command line.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ s2smake \
  --netcdf_format=&quot;netcdf4&quot; \
  --compression_level=1 \
  --output_prefix=&quot;/path/to/outfile_prefix.&quot; \
  --output_suffix=&quot;.000101-001012.nc&quot; \
  -m &quot;time&quot; -m &quot;time_bounds&quot; \
  --specfile=example.s2s \
  /path/to/infiles/*.nc
</pre></div>
</div>
<p>In this example, you will note that we have specified each
time-dependent metadata variable name with its own <code class="docutils literal"><span class="pre">-m</span></code> option. (In
this case, there are only 2, <code class="docutils literal"><span class="pre">time</span></code> and <code class="docutils literal"><span class="pre">time_bounds</span></code>.) We have also
specified the list of input (time-slice) files using a wildcard, which
the Unix shell fills in with a list of all filenames that match this <em>glob</em>
<em>pattern</em>. In this case, we are specifying all files with the <code class="docutils literal"><span class="pre">.nc</span></code> file
extension in the directory <code class="docutils literal"><span class="pre">/path/to/infiles</span></code>. These command-line options
and arguments specify all of the same input needed to run the PyReshaper.
Running this command will save this PyReshaper <em>specfile</em> in a file called
<code class="docutils literal"><span class="pre">example.s2s</span></code>.</p>
<p>When using <em>glob patterns</em>, it is important to understand that the <em>shell</em>
expands these glob patterns out into the full list of matching filenames
<em>before</em> running the <code class="docutils literal"><span class="pre">s2smake</span></code> command.  On many systems, the length of
a shell command is limited to a fixed number of characters, and it is possible
for the <em>glob pattern</em> to expand to a length that makes the command too long
for the shell to execute!  If this is the case, you may contain your glob
pattern in quotation marks (i.e., <code class="docutils literal"><span class="pre">&quot;/path/to/infiles/*.nc&quot;</span></code> instead of
<code class="docutils literal"><span class="pre">/path/to/infiles/*.nc</span></code>).  The <code class="docutils literal"><span class="pre">s2smake</span></code> command will then expand the
glob pattern internally, allowing you to avoid the command-line character
limit of the system.</p>
<p>With the <em>specfile</em> created and saved using the <code class="docutils literal"><span class="pre">s2smake</span></code> utility,
we can run the PyReshaper with this <em>specfile</em> using the <code class="docutils literal"><span class="pre">s2srun</span></code> utility,
with all options and parameters specified on the command line.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ s2srun --serial --verbosity=2 example.s2s
</pre></div>
</div>
<p>The example above shows the execution, in serial, of the PyReshaper job
specified by the <code class="docutils literal"><span class="pre">example.s2s</span></code> <em>specfile</em> with a verbosity
level of 2.</p>
<p>For parallel operation, one must launch the <code class="docutils literal"><span class="pre">s2srun</span></code> script from
the appropriate MPI launcher. On the NCAR Yellowstone system
(<code class="docutils literal"><span class="pre">yellowstone.ucar.edu</span></code>), for example, this is done with the following
command.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ mpirun.lsf s2srun --verbosity=3 example.s2s
</pre></div>
</div>
<p>In the above example, this will launch the <code class="docutils literal"><span class="pre">s2srun</span></code> script into
the MPI environment already created by either a request for an
interactive session or from an LSF submission script.</p>
<div class="section" id="arguments-to-the-s2smake-script">
<h4>Arguments to the <code class="docutils literal"><span class="pre">s2smake</span></code> Script<a class="headerlink" href="#arguments-to-the-s2smake-script" title="Permalink to this headline">¶</a></h4>
<p>The arguments to the <code class="docutils literal"><span class="pre">s2smake</span></code> utility are as follows.</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">--backend</span> <span class="pre">BACKEND</span></code> (<code class="docutils literal"><span class="pre">-b</span> <span class="pre">BACKEND</span></code>):  I/O backend to be used when
reading or writing from NetCDF files.  The parameter <code class="docutils literal"><span class="pre">BACKEND</span></code> can be one
of <code class="docutils literal"><span class="pre">'Nio'</span></code> or <code class="docutils literal"><span class="pre">'netCDF4'</span></code>, indicating PyNIO or netCDF4-python, respectively.
The default value is <code class="docutils literal"><span class="pre">'netCDF4'</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--compression_level</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">-c</span> <span class="pre">C</span></code>):  NetCDF compression level, when using the
netcdf4 file format, where <code class="docutils literal"><span class="pre">C</span></code> is an integer between 0 and 9, with 0 indicating
no compression at all and 9 indicating the highest level of compression. The
default compression level is 1.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--netcdf_format</span> <span class="pre">NCFORMAT</span></code> (<code class="docutils literal"><span class="pre">-f</span> <span class="pre">NCFORMAT</span></code>):  NetCDF file format to be used
for all output files, where <code class="docutils literal"><span class="pre">NCFORMAT</span></code> can be <code class="docutils literal"><span class="pre">'netcdf'</span></code>, <code class="docutils literal"><span class="pre">'netcdf4'</span></code>, or
<code class="docutils literal"><span class="pre">'netcdf4c'</span></code>, indicating NetCDF3 Classic format, NetCDF4 Classic format, or
NetCDF4 Classic format with forced compression level 1.  The default file format
is <code class="docutils literal"><span class="pre">'netcdf4'</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--metadata</span> <span class="pre">VNAME</span></code> (<code class="docutils literal"><span class="pre">-m</span> <span class="pre">VNAME</span></code>):  Indicate that the variable <code class="docutils literal"><span class="pre">VNAME</span></code> should
be treated as metadata, and written to all output files.  There may be more than
one <code class="docutils literal"><span class="pre">--metadata</span></code> (or <code class="docutils literal"><span class="pre">-m</span></code>) options given, each one being added to a list.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--meta1d</span></code> (<code class="docutils literal"><span class="pre">-1</span></code>):  This flag forces all 1D time-variant variables to be treated
as metadata.  These variables need not be added explicitly to the list of metadata
variables (i.e., with the <code class="docutils literal"><span class="pre">--metadata</span></code> or <code class="docutils literal"><span class="pre">-m</span></code> argument).  These variables will
be added to the list when the PyReshaper runs.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--specfile</span> <span class="pre">SPECFILE</span></code> (<code class="docutils literal"><span class="pre">-o</span> <span class="pre">SPECFILE</span></code>):  The name of the <em>specfile</em> to write,
containing the specification of the PyReshaper job.  The default <em>specfile</em> name
is <code class="docutils literal"><span class="pre">'input.s2s'</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--output_prefix</span> <span class="pre">PREFIX</span></code> (<code class="docutils literal"><span class="pre">-p</span> <span class="pre">PREFIX</span></code>):  A string specifying the prefix to be
given to all output filenames.  The output file will be named according to the
rule:</p>
<p><code class="docutils literal"><span class="pre">output_prefix</span> <span class="pre">+</span> <span class="pre">variable_name</span> <span class="pre">+</span> <span class="pre">output_suffix</span></code></p>
<p>The default output filename prefix is <code class="docutils literal"><span class="pre">'tseries.'</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--output_suffix</span> <span class="pre">SUFFIX</span></code> (<code class="docutils literal"><span class="pre">-s</span> <span class="pre">SUFFIX</span></code>):  A string specifying the suffix to be
given to all output filenames.  The output file will be named according to the
rule:</p>
<p><code class="docutils literal"><span class="pre">output_prefix</span> <span class="pre">+</span> <span class="pre">variable_name</span> <span class="pre">+</span> <span class="pre">output_suffix</span></code></p>
<p>The default output filename suffix is <code class="docutils literal"><span class="pre">'.nc'</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">--time_series</span> <span class="pre">VNAME</span></code>:  Indicate that only the named <code class="docutils literal"><span class="pre">VNAME</span></code> variables should
be treated as time-series variables and extracted into their own time-series files.
This option works like the <code class="docutils literal"><span class="pre">--metadata</span></code> option, in that multiple occurrences of
this option can be used to extract out only the time-series variables given.  If
any variable names are given to both the <code class="docutils literal"><span class="pre">--metadata</span></code> and <code class="docutils literal"><span class="pre">--time_series</span></code>
options, then the variable will be treated as metadata.  If the <code class="docutils literal"><span class="pre">--time_series</span></code>
option is <em>not</em> used, then all time-dependent variables that are not specified to
be metadata (i.e., with the <code class="docutils literal"><span class="pre">--metadata</span></code> option) will be treated as time-series
variables and given their own output file.  <strong>NOTE: If you use this option, data
can be left untransformed from time-slice to time-series output!  DO NOT DELETE
YOUR OLD TIME-SLICE FILES!</strong></p>
</li>
</ul>
<p>Each input file should be listed in sequence, space separated, on the command line to
the utility, nominally after all other options have been specified.</p>
</div>
<div class="section" id="arguments-to-the-s2srun-script">
<h4>Arguments to the <code class="docutils literal"><span class="pre">s2srun</span></code> Script<a class="headerlink" href="#arguments-to-the-s2srun-script" title="Permalink to this headline">¶</a></h4>
<p>While the basic options shown in the previous examples above are
sufficient for most purposes, additional options are available.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">--chunk</span> <span class="pre">NAME,SIZE</span></code> (<code class="docutils literal"><span class="pre">-c</span> <span class="pre">NAME,SIZE</span></code>):  This command-line option can be used
to specify a maximum read/write chunk-size <code class="docutils literal"><span class="pre">SIZE</span></code> along a given named dimension
<code class="docutils literal"><span class="pre">NAME</span></code>.  Multiple <code class="docutils literal"><span class="pre">--chunk</span></code> options can be given to specify chunk-sizes along
multiple dimensions.  This option determines the size of the data “chunk” read
from a single input file (and then written to an output file).  If the chunk-size
is greater than the given dimension size, then the entire dimension will be read
at once.  If the chunk-size is less than the given dimension size, then all variables
that depend on that dimension will be read in multiple parts, each “chunk” being written
before the next is read.  This can be important to control memory use.  By default,
chunking is done over the unlimited dimension with a chunk-size of 1.</li>
<li><code class="docutils literal"><span class="pre">--limit</span> <span class="pre">L</span></code> (<code class="docutils literal"><span class="pre">-l</span> <span class="pre">L</span></code>):  This command-line option can be used to set the
<code class="docutils literal"><span class="pre">output_limit</span></code> argument of the PyReshaper <code class="docutils literal"><span class="pre">convert()</span></code> function,
described below.  This can be used when testing to only output the first <code class="docutils literal"><span class="pre">L</span></code>
files.  The default value is 0, which indicates no limit (normal operation).</li>
<li><code class="docutils literal"><span class="pre">--write_mode</span> <span class="pre">M</span></code> (<code class="docutils literal"><span class="pre">-m</span> <span class="pre">M</span></code>): This command-line option can be used to set
the <code class="docutils literal"><span class="pre">wmode</span></code> output file write-mode parameter of the <code class="docutils literal"><span class="pre">create_reshaper()</span></code>
function, described below.  The default write mode is <code class="docutils literal"><span class="pre">'w'</span></code>, which indicates
normal writing, which will error if the output files already exists (i.e.,
no overwriting).  Other options are <code class="docutils literal"><span class="pre">'o'</span></code> to overwrite existing output files,
<code class="docutils literal"><span class="pre">'s'</span></code> to skip existing output files, <code class="docutils literal"><span class="pre">'a'</span></code> to append to existing output
files.</li>
<li><code class="docutils literal"><span class="pre">--serial</span></code> (<code class="docutils literal"><span class="pre">-s</span></code>):  If this flag is used, it will run the PyReshaper in
serial mode.  By default, it will run PyReshaper in parallel mode.</li>
<li><code class="docutils literal"><span class="pre">--verbosity</span> <span class="pre">V</span></code> (<code class="docutils literal"><span class="pre">-v</span> <span class="pre">V</span></code>):  Sets the verbosity level for standard output
from the PyReshaper.  A level of 0 means no output, and a value of 1 or more
means increasingly more output.  The default verbosity level is 1.</li>
</ul>
<p>Nominally, the last argument given to the <code class="docutils literal"><span class="pre">s2srun</span></code> utility should be the name
of the <em>specfile</em> to run.</p>
</div>
</div>
<div class="section" id="using-the-pyreshaper-from-within-python">
<h3>Using the PyReshaper from within Python<a class="headerlink" href="#using-the-pyreshaper-from-within-python" title="Permalink to this headline">¶</a></h3>
<p>Obviously, one of the advantages of writing the PyReshaper in Python is
that it is easy to import features (modules) of the PyReshaper into your
own Python code, as you might link your own software tools to an
external third-party library. The library API for the PyReshaper is
designed to be simple and light-weight, making it easy to use in your
own Python tools or scripts.</p>
<p>Below, we show an example of how to use the PyReshaper from within
Python to convert a stream from time-slice format to time-series
format.</p>
<div class="code py highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyreshaper</span> <span class="k">import</span> <span class="n">specification</span><span class="p">,</span> <span class="n">reshaper</span>

<span class="c1"># Create a Specifier object</span>
<span class="n">specifier</span> <span class="o">=</span> <span class="n">specification</span><span class="o">.</span><span class="n">create_specifier</span><span class="p">()</span>

<span class="c1"># Specify the input needed to perform the PyReshaper conversion</span>
<span class="n">specifier</span><span class="o">.</span><span class="n">input_file_list</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;/path/to/infile1.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;/path/to/infile2.nc&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">specifier</span><span class="o">.</span><span class="n">netcdf_format</span> <span class="o">=</span> <span class="s2">&quot;netcdf4&quot;</span>
<span class="n">specifier</span><span class="o">.</span><span class="n">compression_level</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">specifier</span><span class="o">.</span><span class="n">output_file_prefix</span> <span class="o">=</span> <span class="s2">&quot;/path/to/outfile_prefix.&quot;</span>
<span class="n">specifier</span><span class="o">.</span><span class="n">output_file_suffix</span> <span class="o">=</span> <span class="s2">&quot;.000101-001012.nc&quot;</span>
<span class="n">specifier</span><span class="o">.</span><span class="n">time_variant_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;time_bounds&quot;</span><span class="p">]</span>

<span class="c1"># Create the PyReshaper object</span>
<span class="n">rshpr</span> <span class="o">=</span> <span class="n">reshaper</span><span class="o">.</span><span class="n">create_reshaper</span><span class="p">(</span><span class="n">specifier</span><span class="p">,</span>
                                 <span class="n">serial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                 <span class="n">wmode</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>

<span class="c1"># Run the conversion (slice-to-series) process</span>
<span class="n">rshpr</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Print timing diagnostics</span>
<span class="n">rshpr</span><span class="o">.</span><span class="n">print_diagnostics</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above example, it is important to understand the input given to
the PyReshaper. Namely, all of the input for this single stream is
contained by a single instantiation of a Specifier object (the code for
which is defined in the specification module). We will describe each
attribute of the Specifier object below.</p>
<div class="section" id="specifier-object-attributes">
<h4>Specifier Object Attributes<a class="headerlink" href="#specifier-object-attributes" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">input_file_list</span></code>: This specifies a list of input (time-slice) file
paths that all conform to the input file assumptions (described
above). The list of input files need not be time-ordered, as the
PyReshaper will order them appropriately. (This means that this list
can easily be generated by using filename globs.)</li>
</ul>
<p>In the example above, each file path is full and absolute, for safety’s
sake.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">netcdf_format</span></code>: This is a string specifying what NetCDF format
will be used to write the output (time-series) files.  Acceptable options
for <code class="docutils literal"><span class="pre">netcdf_format</span></code> are: <code class="docutils literal"><span class="pre">&quot;netcdf&quot;</span></code> for NetCDF3 format, <code class="docutils literal"><span class="pre">&quot;netcdf4&quot;</span></code>
for NetCDF4 Classic format, and <code class="docutils literal"><span class="pre">&quot;netcdf4c&quot;</span></code> for NetCDF4 Classic with
level-1 compression.</li>
<li><code class="docutils literal"><span class="pre">compression_level</span></code>: This is an integer specifying the level of
compression to use when writing the output files.  This can be a number
from 0 to 9, where 0 means no compression (default) and 9 mean the
highest level of compression.  This is overridden when the <code class="docutils literal"><span class="pre">&quot;netcdf4c&quot;</span></code>
format is used, where it is forced to be 1.</li>
</ul>
<p>In the above example, NetCDF4 Classic format is used for the output files,
with level-1 compression.  The <code class="docutils literal"><span class="pre">&quot;netcdf4c&quot;</span></code> option can be used as a
short-hand notation for this combination of <code class="docutils literal"><span class="pre">netcdf_format</span></code> and
<code class="docutils literal"><span class="pre">compression_level</span></code> options.</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">output_file_prefix</span></code>: This is a string specifying the common output
(time-series) filename prefix. It is assumed that each time-series
file will be named according to the rule:</p>
<p>filename = output_file_prefix + variable_name + output_file_suffix</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">output_file_suffix</span></code>: This is a string specifying the common output
(time-series) filename suffix. It is assumed that each time-series
file will be named according to the above rule.</p>
</li>
</ul>
<p>It is important to understand, as in the example above, that the prefix
can include the full, absolute path information for the output
(time-series) files.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">time_variant_metadata</span></code>: This specifies a list of variable names
corresponding to variables that should be written to every output
(time-series) NetCDF file.  Nominally, this should specify only the
time-variant (time-dependent) variables that should <em>not</em> be treated
as time-series variables (i.e., treated as metadata), since all
time-invariant (time-independent) variables will be treat as metadata
automatically.</li>
<li><code class="docutils literal"><span class="pre">assume_1d_time_variant_metadata</span></code>: If set to <code class="docutils literal"><span class="pre">True</span></code>, this indicates
that all 1D time-variant variables (i.e., variables that <em>only</em> depend
upon <code class="docutils literal"><span class="pre">time</span></code>) should be added to the list of <code class="docutils literal"><span class="pre">time_variant_metadata</span></code>
when the Reshaper runs.  The default for this option is <code class="docutils literal"><span class="pre">False</span></code>.</li>
<li><code class="docutils literal"><span class="pre">time_series</span></code>: If set to a list of string variable names, only these
variable names will be transformed into time-series format.  This is
equivalent to the <code class="docutils literal"><span class="pre">--time_series</span></code> option to the <code class="docutils literal"><span class="pre">s2smake</span></code> utility.
<strong>NOTE: Setting this attribute can leave data untransformed from time-slice
to time-series format!  DO NOT DELETE YOUR OLD TIME-SLICE FILES!</strong></li>
<li><code class="docutils literal"><span class="pre">backend</span></code>: This specifies which I/O backend to use for reading
and writing NetCDF files.  The default backend is <code class="docutils literal"><span class="pre">'netCDF4'</span></code>, but
the user can alternatively specify <code class="docutils literal"><span class="pre">'Nio'</span></code> to use PyNIO.</li>
</ul>
</div>
<div class="section" id="specifier-object-methods">
<h4>Specifier Object Methods<a class="headerlink" href="#specifier-object-methods" title="Permalink to this headline">¶</a></h4>
<p>In addition to the attributes above, the Specifier objects have some useful
methods that can be called.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">validate()</span></code>:  Calling this function validates the attributes of the
Specifier, making sure their types and values appear correct.</li>
<li><code class="docutils literal"><span class="pre">write(filename)</span></code>:  Calling this function with the argument <code class="docutils literal"><span class="pre">filename</span></code>
will write the <em>specfile</em> matching the Specifier.</li>
</ul>
</div>
<div class="section" id="specfiles">
<h4>Specfiles<a class="headerlink" href="#specfiles" title="Permalink to this headline">¶</a></h4>
<p><em>Specfiles</em> are simply <em>pickled</em> Specifier objects written to a file.  To
create a <em>specfile</em>, one can simply call the Specifier’s <code class="docutils literal"><span class="pre">write()</span></code> method,
described above, or one can explicitly <em>pickle</em> the Specifier directly, as
shown below.</p>
<div class="code py highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="c1"># Assume &quot;spec&quot; is an existing Specifier instance</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;specfile.s2s&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>This is equivalent to the call <code class="docutils literal"><span class="pre">spec.write('specfile.s2s')</span></code>.</p>
<p>A <em>specfile</em> can be read with the following Python code.</p>
<div class="code py highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;specfile.s2s&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="arguments-to-the-create-reshaper-function">
<h4>Arguments to the <code class="docutils literal"><span class="pre">create_reshaper()</span></code> Function<a class="headerlink" href="#arguments-to-the-create-reshaper-function" title="Permalink to this headline">¶</a></h4>
<p>In the example above, the PyReshaper object (rshpr) is created by
passing the single Specifier instance to the <em>factory</em> function
<code class="docutils literal"><span class="pre">create_reshaper()</span></code>. This function returns a PyReshaper object that has
the functions <code class="docutils literal"><span class="pre">convert()</span></code> and <code class="docutils literal"><span class="pre">print_diagnostics()</span></code> that perform the
time-slice to time-series conversion step and print useful timing
diagnostics, respectively.</p>
<p>In addition to the Specifier instance, the <code class="docutils literal"><span class="pre">create_reshaper()</span></code> function
takes the following parameters.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">serial</span></code>: This is a boolean flag, which can be <code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>,
indicating whether the PyReshaper <code class="docutils literal"><span class="pre">convert()</span></code> step should be done in serial
(<code class="docutils literal"><span class="pre">True</span></code>) or parallel (<code class="docutils literal"><span class="pre">False</span></code>). By default, parallel operation is
assumed if this parameter is not specified.</li>
<li><code class="docutils literal"><span class="pre">verbosity</span></code>: This is an integer parameter that specifies what level of
output to produce (to <code class="docutils literal"><span class="pre">stdout</span></code>) during the <code class="docutils literal"><span class="pre">convert()</span></code> step.  A
verbosity level of <code class="docutils literal"><span class="pre">0</span></code> means that no output will be produced, while an
increasing vebosity level producing more and more output.  Currently, a
level of <code class="docutils literal"><span class="pre">2</span></code> produces the most output possible.<ol class="arabic">
<li><code class="docutils literal"><span class="pre">verbosity</span> <span class="pre">=</span> <span class="pre">0</span></code>: This means that no output will be produced unless
specifically requested (i.e., by calling the <code class="docutils literal"><span class="pre">print_diagnostics()</span></code>
function).</li>
<li><code class="docutils literal"><span class="pre">verbosity</span> <span class="pre">=</span> <span class="pre">1</span></code>: This means that only output that would be produced
by the head rank of a parallel process will be generated.</li>
<li><code class="docutils literal"><span class="pre">verbosity</span> <span class="pre">=</span> <span class="pre">2</span></code>: This means that all output from all processors
will be generated, but any output that is the same on all processors
will only be generated once.</li>
</ol>
</li>
<li><code class="docutils literal"><span class="pre">wmode</span></code>: This is a single-character string that can be used to set the
<em>write mode</em> of the PyReshaper.  By default, the PyReshaper will not overwrite
existing output files, if they exist.  In normal operation, this means the
PyReshaper will error (and stop execution) if output files are already
present.  This behavior can be  controlled with the <code class="docutils literal"><span class="pre">wmode</span></code> parameter.
The <code class="docutils literal"><span class="pre">wmode</span></code> parameter can be set to any of the following.<ol class="arabic">
<li><code class="docutils literal"><span class="pre">wmode</span> <span class="pre">=</span> <span class="pre">'w'</span></code>: This indicates that normal write operation is to be
performed.  That is, the PyReshaper will error and stop execution if it
finds output files that already exist.  This is the default setting.</li>
<li><code class="docutils literal"><span class="pre">wmode</span> <span class="pre">=</span> <span class="pre">'s'</span></code>: This indicates that the PyReshaper should skip generating
time-series files for output files that already exist.  No check is
done to see if the output files are correct.</li>
<li><code class="docutils literal"><span class="pre">wmode</span> <span class="pre">=</span> <span class="pre">'o'</span></code>:  This indicates that the PyReshaper should overwrite
existing output files, if present.  In this mode, the existing output
files will be deleted before running the PyReshaper operation.</li>
<li><code class="docutils literal"><span class="pre">wmode</span> <span class="pre">=</span> <span class="pre">'a'</span></code>:  This indicates that the PyReshaper should append to
existing output files, if present.  In this mode, it is assumed that the
existing output files have the correct format before appending new data
to them.</li>
</ol>
</li>
<li><code class="docutils literal"><span class="pre">simplecomm</span></code>: This option allows the user to pass an <code class="docutils literal"><span class="pre">ASAPPyTools</span></code>
<code class="docutils literal"><span class="pre">SimpleComm</span></code> instance to the PyReshaper, instead of having the PyReshaper
create its own internally.  The <code class="docutils literal"><span class="pre">SimpleComm</span></code> object is the simple MPI
communication object used by the PyReshaper to handle its MPI communication.
By default, the PyReshaper will create its own SimpleComm that uses the
MPI <code class="docutils literal"><span class="pre">COMM_WORLD</span></code> communicator for communication.  However, the user
may create their own <code class="docutils literal"><span class="pre">SimpleComm</span></code> object and force the PyReshaper to use
it by setting this option equal to the user-created <code class="docutils literal"><span class="pre">SimpleComm</span></code> instance.</li>
</ul>
</div>
<div class="section" id="arguments-to-the-convert-function">
<h4>Arguments to the <code class="docutils literal"><span class="pre">convert()</span></code> Function<a class="headerlink" href="#arguments-to-the-convert-function" title="Permalink to this headline">¶</a></h4>
<p>While not shown in the above examples, there are named arguments that can
be passed to the <code class="docutils literal"><span class="pre">convert()</span></code> function of the Reshaper object.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">output_limit</span></code>:  This argument sets an integer limit on the number of
time-series files generated during the <code class="docutils literal"><span class="pre">convert()</span></code> operation (per MPI process).
This can be useful for debugging purposes, as it can greatly reduce the length
of time consumed in the <code class="docutils literal"><span class="pre">convert()</span></code> function. A value of <code class="docutils literal"><span class="pre">0</span></code> indicates
no limit, or all output files will be generated.</li>
<li><code class="docutils literal"><span class="pre">chunks</span></code>:  This argument sets a dictionary of dimension names to chunk-sizes.
This is equivalent to the <code class="docutils literal"><span class="pre">--chunk</span></code> command-line option to <code class="docutils literal"><span class="pre">s2srun</span></code>.  This option
determines the size of the data “chunk” read from a single input file (and then written
to an output file) along each given dimension.  If a chunk-size is greater than the given
dimension size, then the entire dimension will be read at once.  If a chunk-size is less
than the given dimension size, then all variables  that depend on that dimension will be
read in multiple parts, each “chunk” being written before the next is read.  This can be
important to control memory use.  By default, the <code class="docutils literal"><span class="pre">chunks</span></code> parameter is equal to
<code class="docutils literal"><span class="pre">None</span></code>, which means chunking is done over the unlimited dimension with a chunk-size of 1.</li>
</ul>
</div>
</div>
<div class="section" id="obtaining-best-performance-with-the-pyreshaper">
<h3>Obtaining Best Performance with the PyReshaper<a class="headerlink" href="#obtaining-best-performance-with-the-pyreshaper" title="Permalink to this headline">¶</a></h3>
<p>While the PyReshaper can be run in either serial or parallel, best performance
is almost always achieved by running in parallel.  Understanding how the
PyReshaper operates, however, is important to knowing how to get the best
performance.</p>
<p>Of critical importance to understanding this, one must appreciate the fact that
the PyReshaper only parallelizes over <em>time-series</em> (output) variables.  Or,
in other words, it parallelizes over output files, since each time-series
variable is written to its own file.  Thus, the maximum amount of parallelism
in the PyReshaper equal to the number of time-series variables in the input
dataset.  If 10 time-series variables exist in the input dataset, then the
maximum performance will be achieved by running the job with 10 MPI processes.</p>
<p>Unfortunately, that is not all that needs to be appreciated, because there are
many factors that can impact performance.</p>
<div class="section" id="shared-memory">
<h4>Shared Memory<a class="headerlink" href="#shared-memory" title="Permalink to this headline">¶</a></h4>
<p>On many parallel systems, with well-scaling parallel software, <em>compute</em>
performance scales with the number of MPI processes, where each process is
executed on its own CPU core.  Multicore CPUs, therefore, can run (efficiently)
as many MPI processes simultaneously as there are cores on the CPU.  These
MPI processes will share the memory attached to the CPU, however, so
memory-intensive MPI processes may require leaving some cores idle on the
CPU in order to leave enough memory for the MPI processes to execute without
an out-of-memory failure.</p>
<p>To best determine how much memory you need on a single MPI process, find the
largest time-series variable in the input dataset.  This can usually be found
by multiplying the size of each dimension upon which the time-series variable
depends, and then multiplying by the byte-size of the variable’s data type.
For example, a <code class="docutils literal"><span class="pre">double</span></code> time-series variable with the dimensions
<code class="docutils literal"><span class="pre">('time',</span> <span class="pre">'lat',</span> <span class="pre">'lon')</span></code>, would have a byte-size of the following.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">S_B</span><span class="p">(</span><span class="s1">&#39;var&#39;</span><span class="p">)</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">S_B</span><span class="p">(</span><span class="s1">&#39;double&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">S(d)</span></code> represents the numeric size of dimension <code class="docutils literal"><span class="pre">d</span></code>, and <code class="docutils literal"><span class="pre">S_B(v)</span></code>
represents the number of bytes of the variable <code class="docutils literal"><span class="pre">v</span></code>.  (The <code class="docutils literal"><span class="pre">S_B('double')</span></code>
is equal to 8 bytes, while <code class="docutils literal"><span class="pre">S_B('float')</span></code> is equal to 4 bytes.)  If we
assume <code class="docutils literal"><span class="pre">S('time')</span> <span class="pre">=</span> <span class="pre">14600</span></code>, <code class="docutils literal"><span class="pre">S('lat')</span> <span class="pre">=</span> <span class="pre">180</span></code>, and <code class="docutils literal"><span class="pre">S('lon')</span> <span class="pre">=</span> <span class="pre">360</span></code>, then
<code class="docutils literal"><span class="pre">S_B('var')</span> <span class="pre">=</span> <span class="pre">7</span></code> GB.</p>
<p>If you then run <code class="docutils literal"><span class="pre">N</span></code> MPI processes on each node, each MPI process has roughly
<a href="#id1"><span class="problematic" id="id2">``</span></a>1/N``th of the memory available to it, and this memory must be large enough
to contain the time-series variable.  So, on a system with 16 cores per node,
and 64 GB per node, has only (on average) 4 GB per core.  The above time-series
variable would not fit in only 4 GB, but it would fit in 8 GB, so we might use
only 8 of the 16 available cores per node in our PyReshaper run.</p>
</div>
<div class="section" id="i-o-nodes">
<h4>I/O Nodes<a class="headerlink" href="#i-o-nodes" title="Permalink to this headline">¶</a></h4>
<p>Similar limitations usually apply to <em>I/O</em> (reading/writing data) operations,
of which the PyReshaper is one.  The PyReshaper does very little computation
on the CPU, and almost all of its operation time is dominated by I/O.
Unfortunately, most systems have serial I/O from all MPI processes on the same
CPU (or <em>node</em>).  Hence, while a multicore CPU can efficiently execute as many
MPI processes as cores on the CPU for <em>computation</em>, this may not be true for
I/O.  To prevent overloading the node’s I/O capabilities, it may be necessary
to run fewer PyReshaper processes <em>per node</em> than there are available cores.</p>
<p>This is a parameter that is hard to get a feel for, so it is best to see how
performance varies on the system you are using.  In general, though, using the
maximum number of processes per node will saturate the I/O capabilities of the
node, so using fewer processes per node may improve conversion speeds.</p>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pyconform.html" class="btn btn-neutral float-right" title="The PyConform Package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="readme.html" class="btn btn-neutral" title="PyConform" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, University Corporation for Atmospheric Research.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>